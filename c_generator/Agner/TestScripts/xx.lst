     1                              <1> ; miscellaneous.inc                                              2013-07-06 Agner Fog
     2                              <1> ; Define test code for miscellaneous integer and general purpose instructions
     3                              <1> ; (c) Copyright 2013 by Agner Fog. GNU General Public License www.gnu.org/licenses
     4                              <1> 
     5                              <1> ; instruction-specific test codes
     6                              <1> 
     7                              <1> ; define NOP of variable length
     8                              <1> %macro noplengthx 1
     9                              <1>    %if %1 == 0
    10                              <1>       ; nothing
    11                              <1>    %elif %1 == 1
    12                              <1>       nop
    13                              <1>    %elif %1 == 2
    14                              <1>       db 66H, 90H
    15                              <1>    %elif %1 == 3
    16                              <1>       db 0FH, 1FH, 0C0H
    17                              <1>    %elif %1 == 4
    18                              <1>       db 0FH, 1FH, 40H, 00H
    19                              <1>    %elif %1 == 5
    20                              <1>       db 0FH, 1FH, 44H, 00H, 00H
    21                              <1>    %elif %1 == 6
    22                              <1>       db 66H, 0FH, 1FH, 44H, 00H, 00H
    23                              <1>    %elif %1 == 7
    24                              <1>       db 0FH, 1FH, 80H, 00H, 00H, 00H, 00H
    25                              <1>    %elif %1 == 8
    26                              <1>       db 0FH, 1FH, 84H, 00H, 00H, 00H, 00H, 00H
    27                              <1>    %elif %1 == 9
    28                              <1>       db 66H, 0FH, 1FH, 84H, 00H, 00H, 00H, 00H, 00H
    29                              <1>    %elif %1 == 10
    30                              <1>       db 66H, 66H, 0FH, 1FH, 84H, 00H, 00H, 00H, 00H, 00H
    31                              <1>    %elif %1 == 11
    32                              <1>       db 66H, 66H, 66H, 0FH, 1FH, 84H, 00H, 00H, 00H, 00H, 00H
    33                              <1>    %else
    34                              <1>       %error "unknown noplength"
    35                              <1>    %endif
    36                              <1> %endmacro
    37                              <1> 
    38                              <1> ; define optional lock prefix
    39                              <1> %ifdef lockprefix
    40                              <1>    %if lockprefix == 1
    41                              <1>       %define prefix lock
    42                              <1>    %else
    43                              <1>       %define prefix
    44                              <1>    %endif
    45                              <1> %endif
    46                              <1> 
    47                              <1> ; Define specific test code for each instruction case:
    48                              <1> 
    49                              <1> %ifidni instruct, call_without_return
    50                              <1> 
    51                              <1>    %if regsize == 32 
    52                              <1>       %macro testinit2 0
    53                              <1>          mov ebx,esp
    54                              <1>       %endmacro
    55                              <1>       %macro testafter1 0
    56                              <1>          mov esp,ebx
    57                              <1>       %endmacro
    58                              <1>    %else
    59                              <1>       %macro testinit2 0
    60                              <1>          mov rbx,rsp
    61                              <1>       %endmacro
    62                              <1>       %macro testafter1 0
    63                              <1>          mov rsp,rbx
    64                              <1>       %endmacro
    65                              <1>    %endif
    66                              <1> 
    67                              <1>    %macro testcode 0
    68                              <1>       call $ + 8
    69                              <1>       nop
    70                              <1>       nop
    71                              <1>       nop
    72                              <1>    %endmacro
    73                              <1> 
    74                              <1> %elifidni instruct, call_and_return
    75                              <1> 
    76                              <1>    %ifndef nnops
    77                              <1>       %define nnops 0
    78                              <1>    %endif
    79                              <1>    %macro testinit1 0
    80                              <1>       jmp testinit1end
    81                              <1>       nop
    82                              <1>       align 32
    83                              <1>       testfunction:  ; make a dummy function that we can call
    84                              <1>       %rep nnops / 2
    85                              <1>          nop
    86                              <1>       %endrep
    87                              <1>       ret
    88                              <1>       align 16
    89                              <1>       testinit1end:
    90                              <1>    %endmacro
    91                              <1>    %macro testcode 0
    92                              <1>       call testfunction
    93                              <1>       %rep nnops / 2
    94                              <1>          nop
    95                              <1>       %endrep
    96                              <1>    %endmacro
    97                              <1> 
    98                              <1> %elifidni instruct, call_return_longnop
    99                              <1> 
   100                              <1>    %macro testinit1 0
   101                              <1>       jmp testinit1end
   102                              <1>       nop
   103                              <1>       align 32
   104                              <1>       testfunction:  ; make a dummy function that we can call
   105                              <1>       ret
   106                              <1>       align 16
   107                              <1>       testinit1end:
   108                              <1>    %endmacro
   109                              <1>    %macro testcode 0
   110                              <1>       call testfunction
   111                              <1>       noplengthx noplen
   112                              <1>    %endmacro
   113                              <1> 
   114                              <1> %elifidni instruct, push_call_return_imm
   115                              <1> 
   116                              <1>    %macro testinit1 0
   117                              <1>       jmp testinit1end
   118                              <1>       nop
   119                              <1>       align 32
   120                              <1>       testfunction:  ; make a dummy function that we can call
   121                              <1>       ret regsize / 8
   122                              <1>       align 16
   123                              <1>       testinit1end:
   124                              <1>    %endmacro
   125                              <1>    %macro testcode 0
   126                              <1>       push reg0
   127                              <1>       call testfunction
   128                              <1>       noplengthx noplen
   129                              <1>    %endmacro
   130                              <1> 
   131                              <1> %elifidni instruct, call_register_and_return
   132                              <1> 
   133                              <1>    %macro testinit1 0
   134                              <1>       jmp testinit1end
   135                              <1>       nop
   136                              <1>       align 32
   137                              <1>       testfunction:  ; make a dummy function that we can call
   138                              <1>       ret
   139                              <1>       align 16
   140                              <1>       testinit1end:
   141                              <1>       %if regsize == 32 
   142                              <1>          mov edi, testfunction
   143                              <1>       %else
   144                              <1>          lea rdi, [testfunction]
   145                              <1>       %endif
   146                              <1>    %endmacro
   147                              <1>    %macro testcode 0
   148                              <1>       call reg4
   149                              <1>       noplengthx noplen
   150                              <1>    %endmacro
   151                              <1> 
   152                              <1> %elifidni instruct, call_memory_and_return
   153                              <1> 
   154                              <1>    %macro testinit1 0
   155                              <1>       jmp testinit1end
   156                              <1>       nop
   157                              <1>       align 32
   158                              <1>       testfunction:  ; make a dummy function that we can call
   159                              <1>       ret
   160                              <1>       align 16
   161                              <1>       testinit1end:
   162                              <1>       %if regsize == 32 
   163                              <1>          mov edi, testfunction
   164                              <1>          mov [esi], edi
   165                              <1>       %else
   166                              <1>          lea rdi, [testfunction]
   167                              <1>          mov [rsi], rdi
   168                              <1>       %endif
   169                              <1>    %endmacro
   170                              <1>    %macro testcode 0
   171                              <1>       call [reg5]
   172                              <1>       noplengthx noplen
   173                              <1>    %endmacro
   174                              <1> 
   175                              <1> %elifidni instruct, jmp
   176                              <1>    %ifndef jmp_per_16b
   177                              <1>       %define jmp_per_16b 2
   178                              <1>    %endif
   179                              <1> 
   180                              <1>    %assign repcnt 0
   181                              <1>    %macro testcode 0
   182                              <1>       %if jmp_per_16b == 8
   183                              <1>          jmp $+2
   184                              <1>       %elif jmp_per_16b == 6
   185                              <1>          %if repcnt % 3 == 0
   186                              <1>             jmp $+2
   187                              <1>          %else
   188                              <1>             jmp $+3
   189                              <1>             nop
   190                              <1>          %endif
   191                              <1>       %elif jmp_per_16b == 5
   192                              <1>          %if repcnt % 5 == 0
   193                              <1>             jmp $+4
   194                              <1>             noplengthx 2
   195                              <1>          %else
   196                              <1>             jmp $+3
   197                              <1>             nop
   198                              <1>          %endif
   199                              <1>       %elif jmp_per_16b == 4
   200                              <1>          jmp $+4
   201                              <1>          noplengthx 2
   202                              <1>       %elif jmp_per_16b == 3
   203                              <1>          %if repcnt % 3 == 0
   204                              <1>             jmp $+6
   205                              <1>             noplengthx 4
   206                              <1>          %else
   207                              <1>             jmp $+5
   208                              <1>             noplengthx 3
   209                              <1>          %endif
   210                              <1>       %elif jmp_per_16b == 2
   211                              <1>          jmp $+8
   212                              <1>          noplengthx 6
   213                              <1>       %elif jmp_per_16b == 1
   214                              <1>          jmp $+16
   215                              <1>          noplengthx 7
   216                              <1>          noplengthx 7
   217                              <1>       %else
   218                              <1>          %error unknown jmp_per_16b
   219                              <1>       %endif
   220                              <1>       %assign repcnt repcnt+1
   221                              <1>    %endmacro
   222                              <1> 
   223                              <1> %elifidni instruct, jmp_register
   224                              <1>    %ifndef jmp_per_16b
   225                              <1>       %define jmp_per_16b 1
   226                              <1>    %endif
   227                              <1>    %macro testcode 0
   228                              <1>       %if jmp_per_16b == 1
   229                              <1>          lea rbx, [rel $+16]
   230                              <1>          jmp rbx
   231                              <1>          noplengthx 7
   232                              <1>       %else
   233                              <1>          %error unknown jmp_per_16b
   234                              <1>       %endif
   235                              <1>    %endmacro
   236                              <1> 
   237                              <1> %elifidni instruct, jmp_memory
   238                              <1>    %ifndef jmp_per_16b
   239                              <1>       %define jmp_per_16b 1
   240                              <1>    %endif
   241                              <1>    %macro testcode 0
   242                              <1>       %if jmp_per_16b == 1
   243                              <1>          lea rbx, [rel $+16]
   244                              <1>          mov [rsi],rbx
   245                              <1>          jmp [rsi]
   246                              <1>          noplengthx 4
   247                              <1>       %else
   248                              <1>          %error unknown jmp_per_16b
   249                              <1>       %endif
   250                              <1>    %endmacro
   251                              <1> 
   252                              <1> %elifidni instruct, conditional_jmp
   253                              <1> 
   254                              <1>    %ifndef jmp_per_16b
   255                              <1>       %define jmp_per_16b 2
   256                              <1>    %endif
   257                              <1>    %ifndef jmptaken
   258                              <1>       %define jmptaken true  ; can be true, false, alternate
   259                              <1>    %endif
   260                              <1> 
   261                              <1>    %macro testinit3 0        ; set carry flag before repeat macro
   262                              <1>       %ifidni jmptaken, no
   263                              <1>          clc                 ; carry flag = 0
   264                              <1>       %elifidni jmptaken, yes
   265                              <1>          stc                 ; carry flag = 1
   266                              <1>       %elifidni jmptaken, alternate
   267                              <1>          %if regsize == 64
   268                              <1>             mov eax, r14d    ; get carry flag from loop counter
   269                              <1>          %else
   270                              <1>             mov eax, dword [esp+8]
   271                              <1>          %endif
   272                              <1>          shr eax, 1
   273                              <1>       %endif
   274                              <1>    %endmacro
   275                              <1> 
   276                              <1>    %assign repcnt 0
   277                              <1>    %macro testcode 0
   278                              <1>       %if jmp_per_16b == 8
   279                              <1>          jc $+2
   280                              <1>       %elif jmp_per_16b == 6
   281                              <1>          %if repcnt % 3 == 0
   282                              <1>             jc $+2
   283                              <1>          %else
   284                              <1>             jc $+3
   285                              <1>             nop
   286                              <1>          %endif
   287                              <1>       %elif jmp_per_16b == 5
   288                              <1>          %if repcnt % 5 == 0
   289                              <1>             jc $+4
   290                              <1>             noplengthx 2
   291                              <1>          %else
   292                              <1>             jc $+3
   293                              <1>             nop
   294                              <1>          %endif
   295                              <1>       %elif jmp_per_16b == 4
   296                              <1>          jc $+4
   297                              <1>          noplengthx 2
   298                              <1>       %elif jmp_per_16b == 3
   299                              <1>          %if repcnt % 3 == 0
   300                              <1>             jc $+6
   301                              <1>             noplengthx 4
   302                              <1>          %else
   303                              <1>             jc $+5
   304                              <1>             noplengthx 3
   305                              <1>          %endif
   306                              <1>       %elif jmp_per_16b == 2
   307                              <1>          jc $+8
   308                              <1>          noplengthx 6
   309                              <1>       %elif jmp_per_16b == 1
   310                              <1>          jc $+16
   311                              <1>          noplengthx 7
   312                              <1>          noplengthx 7
   313                              <1>       %else
   314                              <1>          %error unknown jmp_per_16b
   315                              <1>       %endif
   316                              <1>       %assign repcnt repcnt+1
   317                              <1>    %endmacro
   318                              <1> 
   319                              <1> %elifidni instruct, jecxz
   320                              <1>    ; alternate, 2 per 16 bytes
   321                              <1> 
   322                              <1>    %macro testinit2 0        ; set ecx to bit 1 of loop counter
   323                              <1>       %if modesize == 64
   324                              <1>          mov ecx, r14d
   325                              <1>       %else
   326                              <1>          mov ecx, dword [esp+8]
   327                              <1>       %endif
   328                              <1>       and ecx, 2
   329                              <1>    %endmacro
   330                              <1>    %macro testcode 0
   331                              <1>       jecxz $+8
   332                              <1>       %if modesize == 64
   333                              <1>          noplengthx 5  ; compensate for 67h prefix
   334                              <1>       %else
   335                              <1>          noplengthx 6
   336                              <1>       %endif
   337                              <1>    %endmacro
   338                              <1> 
   339                              <1> %elifidni instruct, jrcxz
   340                              <1>    ; alternate, 2 per 16 bytes
   341                              <1> 
   342                              <1>    %macro testinit2 0        ; set ecx to bit 1 of loop counter
   343                              <1>       mov ecx, r14d
   344                              <1>       and ecx, 2
   345                              <1>    %endmacro
   346                              <1>    %macro testcode 0
   347                              <1>       jrcxz $+8
   348                              <1>       noplengthx 6
   349                              <1>    %endmacro
   350                              <1> 
   351                              <1> %elifidni instruct, loop     ; 64 bit mode, 2 per 16 bytes
   352                              <1> 
   353                              <1>    %macro testinit2 0 
   354                              <1>       %ifidni taken, alternate
   355                              <1>          mov ebx, r14d       ; loop counter
   356                              <1>          shr ebx, 1
   357                              <1>          and ebx, 1
   358                              <1>          inc ebx
   359                              <1>       %else 
   360                              <1>          mov ebx,10
   361                              <1>       %endif
   362                              <1>    %endmacro
   363                              <1>    %macro testcode 0
   364                              <1>       %ifidni taken, alternate
   365                              <1>          mov ecx,ebx
   366                              <1>          loop $+6
   367                              <1>          noplengthx 4
   368                              <1>       %else      ; taken = yes
   369                              <1>          mov ecx,ebx
   370                              <1>          loop $
   371                              <1>          noplengthx 4
   372                              <1>       %endif
   373                              <1>    %endmacro
   374                              <1> 
   375                              <1> %elifidni instruct, loope     ; 64 bit mode, alternate, 2 per 16 bytes
   376                              <1> 
   377                              <1>    %macro testinit2 0 
   378                              <1>       mov ebx, r14d       ; loop counter
   379                              <1>       shr ebx, 1
   380                              <1>       and ebx, 1
   381                              <1>       inc ebx
   382                              <1>    %endmacro
   383                              <1>    %macro testinit3 0 
   384                              <1>       cmp eax,eax
   385                              <1>    %endmacro
   386                              <1>    %macro testcode 0
   387                              <1>       mov ecx,ebx
   388                              <1>       loope $+6
   389                              <1>       noplengthx 4
   390                              <1>    %endmacro
   391                              <1> 
   392                              <1> %elifidni instruct, loopne     ; 64 bit mode, alternate, 2 per 16 bytes
   393                              <1> 
   394                              <1>    %macro testinit2 0 
   395                              <1>       mov ebx, r14d       ; loop counter
   396                              <1>       shr ebx, 1
   397                              <1>       and ebx, 1
   398                              <1>       inc ebx
   399                              <1>    %endmacro
   400                              <1>    %macro testcode 0
   401                              <1>       mov ecx,ebx
   402                              <1>       loopne $+6
   403                              <1>       noplengthx 4
   404                              <1>    %endmacro
   405                              <1> 
   406                              <1> %elifidni instruct, fused_alu_jmp     ; Possibly fused ALU instruction + conditional jump, 64 bit mode, alternate, 2 per 16 bytes
   407                              <1>    ; instruct1 = cmp, test, add, and
   408                              <1> 
   409                              <1>    %macro testinit2 0 
   410                              <1>       mov ebx, r14d       ; loop counter
   411                              <1>       and ebx, 1
   412                              <1>    %endmacro
   413                              <1>    %macro testcode 0
   414                              <1>       %ifidni instruct1, cmp
   415                              <1>          cmp ebx,1
   416                              <1>          jb  $+5
   417                              <1>          noplengthx 3
   418                              <1>       %elifidni instruct1, test
   419                              <1>          test ebx,ebx
   420                              <1>          jnz  $+6
   421                              <1>          noplengthx 4
   422                              <1>       %elifidni instruct1, add
   423                              <1>          add ebx,0
   424                              <1>          jnz  $+5
   425                              <1>          noplengthx 3
   426                              <1>       %elifidni instruct1, and
   427                              <1>          and ebx,-1
   428                              <1>          jz  $+5
   429                              <1>          noplengthx 3
   430                              <1>       %else
   431                              <1>          %error unknown instruct1
   432                              <1>       %endif
   433                              <1>    %endmacro
   434                              <1> 
   435                              <1> %elifidni instruct, xlatb
   436                              <1> 
   437                              <1>    %macro testinit1 0 
   438                              <1>       mov dword [rsi], 1
   439                              <1>    %endmacro
   440                              <1>    %macro testinit2 0 
   441                              <1>       mov rbx, rsi
   442                              <1>       xor eax,eax
   443                              <1>    %endmacro
   444                              <1>    %macro testcode 0
   445                              <1>       %ifidni tmode, L
   446                              <1>          xlatb
   447                              <1>       %elifidni tmode, T
   448                              <1>          xor eax,eax
   449                              <1>          xlatb
   450                              <1>       %endif
   451                              <1>    %endmacro
   452                              <1> 
   453                              <1> %elifidni instruct, rdpmc
   454                              <1> 
   455                              <1>    %macro testinit2 0 
   456                              <1>       xor ecx,ecx
   457                              <1>    %endmacro
   458                              <1> 
   459                              <1> %elifidni instruct, inc
   460                              <1> 
   461                              <1>    %macro testcode 0
   462                              <1>       %ifidni tmode, L  ; test latency of flag output
   463                              <1>          inc eax
   464                              <1>          sbb eax,eax
   465                              <1>       %elifidni tmode, T
   466                              <1>          inc eax
   467                              <1>          sub eax,ebx
   468                              <1>       %endif
   469                              <1>    %endmacro
   470                              <1> 
   471                              <1> %elifidni instruct, lea
   472                              <1> 
   473                              <1>    ; parameters:
   474                              <1>    ; tmode:    L = latency, T = throughput, R = throughput rip-relative, LM = latency to mov instruction, LA = latency to add instruction, 
   475                              <1>    ; addrsize: 16, 32, 64  ; base and index register
   476                              <1>    ; regsize:  16, 32, 64  ; destination register
   477                              <1>    ; basereg:  0, 1
   478                              <1>    ; scalef:   0, 1, 2, 4, 8
   479                              <1>    ; ioffset:  0, 1, 4   bytes
   480                              <1>    ; aprefix:  0, 1        ; address size prefix, overriding specified addrsize
   481                              <1>    
   482                              <1>    %ifndef aprefix
   483                              <1>       %define aprefix 0
   484                              <1>    %endif
   485                              <1>    %ifndef tmode
   486                              <1>       %define tmode L
   487                              <1>    %endif
   488                              <1>    %ifndef addrsize
   489                              <1>       %define addrsize 64
   490                              <1>    %endif
   491                              <1>    %ifndef regsize
   492                              <1>       %define regsize 32
   493                              <1>    %endif
   494                              <1>    %ifndef basereg
   495                              <1>       %define basereg 1
   496                              <1>    %endif
   497                              <1>    %ifndef scalef
   498                              <1>       %define scalef 0
   499                              <1>    %endif
   500                              <1>    %ifndef ioffset
   501                              <1>       %define ioffset 1
   502                              <1>    %endif
   503                              <1> 
   504                              <1>    %if basereg
   505                              <1>       %if addrsize == 16
   506                              <1>          %define basereg_  bx
   507                              <1>       %elif addrsize == 32
   508                              <1>          %define basereg_  ebx
   509                              <1>       %elif addrsize == 64
   510                              <1>          %define basereg_  rbx
   511                              <1>       %endif
   512                              <1>    %else
   513                              <1>       %define basereg_
   514                              <1>    %endif
   515                              <1>    %if basereg
   516                              <1>       %define plus1 +   ; + before scale*index
   517                              <1>    %else
   518                              <1>       %define plus1
   519                              <1>    %endif
   520                              <1>    %if basereg + scalef
   521                              <1>       %define plus2 +   ; + before offset
   522                              <1>    %else
   523                              <1>       %define plus2
   524                              <1>    %endif
   525                              <1>    %if scalef
   526                              <1>       %if addrsize == 16
   527                              <1>          %define scaledindex plus1 si
   528                              <1>       %elif addrsize == 32
   529                              <1>          %define scaledindex  plus1 scalef*esi
   530                              <1>       %elif addrsize == 64
   531                              <1>          %define scaledindex  plus1 scalef*rsi
   532                              <1>       %endif
   533                              <1>    %else
   534                              <1>       %define scaledindex
   535                              <1>    %endif
   536                              <1>    %if ioffset == 0
   537                              <1>       %if basereg + scalef
   538                              <1>          %define offset_
   539                              <1>       %else
   540                              <1>          %define offset_  0
   541                              <1>       %endif
   542                              <1>    %elif ioffset == 1
   543                              <1>       %define offset_ plus2 5
   544                              <1>    %else
   545                              <1>       %define offset_ plus2 500
   546                              <1>    %endif
   547                              <1>    %if basereg
   548                              <1>       %define destreg reg1
   549                              <1>    %else
   550                              <1>       %define destreg reg5
   551                              <1>    %endif
   552                              <1>    
   553                              <1>    %macro testcode 0
   554                              <1>       %if aprefix
   555                              <1>          db 0x67   ; hard code address size prefix
   556                              <1>       %endif 
   557                              <1>       %ifidni tmode, L
   558                              <1>          lea destreg , [ basereg_ scaledindex offset_ ]
   559                              <1>       %elifidni tmode, T
   560                              <1>          lea reg0 , [ basereg_ scaledindex offset_ ]
   561                              <1>       %elifidni tmode, R
   562                              <1>          lea reg2 , [ rel UserData ]
   563                              <1>       %elifidni tmode, LM
   564                              <1>          lea destreg , [ basereg_ scaledindex offset_ ]
   565                              <1>          mov destreg, destreg
   566                              <1>       %elifidni tmode, LA
   567                              <1>          lea destreg , [ basereg_ scaledindex offset_ ]
   568                              <1>          add destreg, destreg
   569                              <1>       %endif
   570                              <1>    %endmacro
   571                              <1> 
   572                              <1> %elifidni instruct, mov_r_m   ; mov register, memory, different addressing modes
   573                              <1> 
   574                              <1>    %macro testinit2 0
   575                              <1>       xor ebx,ebx
   576                              <1>    %endmacro
   577                              <1>    %macro testcode 0
   578                              <1>       %ifidni addrmode, INDIR             ; indirect addressing
   579                              <1>          mov reg0, [rsi+rbx*4]
   580                              <1>       %elifidni addrmode, RIP             ; rip relative addressing
   581                              <1>          mov reg0, [rel UserData]
   582                              <1>       %elifidni addrmode, ABS32           ; 32 bit absolute address
   583                              <1>          mov reg0, [abs dword UserData]
   584                              <1>       %elifidni addrmode, ABS64           ; 64 bit absolute address
   585                              <1>          mov reg0, [abs qword UserData]
   586                              <1>       %endif
   587                              <1>    %endmacro
   588                              <1> 
   589                              <1> %elifidni instruct, mov_m_r   ; mov memory, register, different addressing modes
   590                              <1> 
   591                              <1>    %macro testinit2 0
   592                              <1>       xor ebx,ebx
   593                              <1>    %endmacro
   594                              <1>    %macro testcode 0
   595                              <1>       %ifidni addrmode, INDIR             ; indirect addressing
   596                              <1>          mov [rsi+rbx*4], reg0
   597                              <1>       %elifidni addrmode, RIP             ; rip relative addressing
   598                              <1>          mov [rel UserData], reg0
   599                              <1>       %elifidni addrmode, ABS32           ; 32 bit absolute address
   600                              <1>          mov [abs dword UserData], reg0
   601                              <1>       %elifidni addrmode, ABS64           ; 64 bit absolute address
   602                              <1>          mov [abs qword UserData], reg0
   603                              <1>       %endif
   604                              <1>    %endmacro
   605                              <1> 
   606                              <1> %elifidni instruct, set
   607                              <1> 
   608                              <1>    %define repeat2 1
   609                              <1>    %macro testcode 0
   610                              <1>       %ifidni tmode, L         ; measure latency
   611                              <1>          %rep 100
   612                              <1>             sete al
   613                              <1>             neg al
   614                              <1>          %endrep
   615                              <1>       %elifidni tmode, T         ; measure throughput with register operands
   616                              <1>          %rep 50
   617                              <1>             sete al
   618                              <1>             setc bl
   619                              <1>          %endrep
   620                              <1>       %elifidni tmode, M         ; measure throughput with memory source operand
   621                              <1>          %rep 50
   622                              <1>             sete byte [rsi]
   623                              <1>             setnc byte [rdi]
   624                              <1>          %endrep
   625                              <1>       %else
   626                              <1>          %error unknown testmode
   627                              <1>       %endif
   628                              <1>    %endmacro
   629                              <1> 
   630                              <1> %elifidni instruct, maskmovq
   631                              <1> 
   632                              <1>    %define repeat1 100
   633                              <1>    %macro testinit2 0
   634                              <1>       %if   immvalue == 0x00     ; all bytes 00
   635                              <1>          pxor mm0,mm0      
   636                              <1>       %elif immvalue == 0x02     ; one byte ff
   637                              <1>          mov eax, 0000ff00h
   638                              <1>          movd  mm0, eax
   639                              <1>       %elif immvalue == 0x55     ; alternate 00 ff bytes
   640                              <1>          pcmpeqw mm0,mm0
   641                              <1>          psrlw   mm0, 8      
   642                              <1>       %elif immvalue == 0x33     ; alternate 00 00 ff ff bytes
   643                              <1>          pcmpeqw mm0,mm0
   644                              <1>          psrld   mm0, 16     
   645                              <1>       %elif immvalue == 0xFF     ; all bytes ff
   646                              <1>          pcmpeqw mm0,mm0     
   647                              <1>       %else
   648                              <1>          %error unsupported immvalue
   649                              <1>       %endif
   650                              <1>    %endmacro
   651                              <1>    %macro testcode 0
   652                              <1>       %ifidni tmode, T           ; measure throughput
   653                              <1>          maskmovq mm1, mm0
   654                              <1>       %elifidni tmode, L         ; measure latency
   655                              <1>          maskmovq mm1, mm0
   656                              <1>          movq mm1, [rdi]
   657                              <1>       %else
   658                              <1>          %error unknown testmode
   659                              <1>       %endif
   660                              <1>    %endmacro
   661                              <1> 
   662                              <1> %elifidni instruct, maskmovdqu
   663                              <1> 
   664                              <1>    %define repeat1 100
   665                              <1>    %macro testinit2 0
   666                              <1>       %if immvalue   == 0x00     ; all bytes 00
   667                              <1>          pxor xmm0,xmm0   
   668                              <1>       %elif immvalue == 0x02     ; one byte ff
   669                              <1>          mov eax, 0000ff00h
   670                              <1>          movd  xmm0, eax
   671                              <1>       %elif immvalue == 0x55     ; alternate 00 ff bytes
   672                              <1>          pcmpeqw xmm0,xmm0
   673                              <1>          psrlw   xmm0, 8    
   674                              <1>       %elif immvalue == 0x33     ; alternate 00 00 ff ff bytes
   675                              <1>          pcmpeqw xmm0,xmm0
   676                              <1>          psrld   xmm0, 16  
   677                              <1>       %elif immvalue == 0xFF     ; all bytes ff
   678                              <1>          pcmpeqw xmm0,xmm0   
   679                              <1>       %else
   680                              <1>          %error unsupported immvalue
   681                              <1>       %endif
   682                              <1>    %endmacro
   683                              <1>    %macro testcode 0
   684                              <1>       %ifidni tmode, T           ; measure throughput
   685                              <1>          maskmovdqu xmm1, xmm0
   686                              <1>       %elifidni tmode, L         ; measure latency
   687                              <1>          maskmovdqu xmm1, xmm0
   688                              <1>          movdqa xmm1, [rdi]
   689                              <1>       %else
   690                              <1>          %error unknown testmode
   691                              <1>       %endif
   692                              <1>    %endmacro
   693                              <1> 
   694                              <1> %elifidni instruct, vmaskmov  ; vmaskmovps / vmaskmovpd with memory source or destination operand
   695                              <1>    ; specify instruct1 = vmaskmovps or vmaskmovpd
   696                              <1>    ; specify tmode: TRM = throughput with memory source, LRM = latency with memory source,
   697                              <1>    ;                TMR = throughput with memory destination, LMR = latency with memory destination
   698                              <1>    ; specify immvalue to one of the values 0x00 0x02 0x55 0x33 0xff to define a mask
   699                              <1> 
   700                              <1>    %define repeat1 100
   701                              <1>    %define repeat2 100
   702                              <1> 
   703                              <1>    %macro testinit2 0
   704                              <1>       lea rsi, [UserData]
   705                              <1>       ; make mask
   706                              <1>       %ifidni instruct1, vmaskmovps
   707                              <1>          %if immvalue   == 0x00     ; all bytes 00
   708                              <1>             vpxor xmm0,xmm0,xmm0   
   709                              <1>          %elif immvalue == 0x02     ; one dword ff
   710                              <1>             mov eax, -1
   711                              <1>             vmovd  xmm0, eax
   712                              <1>             vshufps ymm0,ymm0,ymm0,04h
   713                              <1>          %elif immvalue == 0x55     ; alternate 00 ff dwords
   714                              <1>             mov eax, -1
   715                              <1>             vmovd  xmm0, eax
   716                              <1>             vshufps ymm0,ymm0,ymm0,11h
   717                              <1>             vinsertf128 ymm0,ymm0,xmm0,1
   718                              <1>          %elif immvalue == 0x33     ; alternate 00 00 ff ff bytes
   719                              <1>             mov eax, -1
   720                              <1>             vmovd  xmm0, eax
   721                              <1>             vshufps ymm0,ymm0,ymm0,05h
   722                              <1>             vinsertf128 ymm0,ymm0,xmm0,1
   723                              <1>          %elif immvalue == 0xFF     ; all bytes ff
   724                              <1>             vpcmpeqw xmm0,xmm0,xmm0
   725                              <1>             vinsertf128 ymm0,ymm0,xmm0,1
   726                              <1>          %else
   727                              <1>             %error unsupported immvalue
   728                              <1>          %endif
   729                              <1>       %elifidni instruct1, vmaskmovpd
   730                              <1>          %if immvalue   == 0x00     ; all bytes 00
   731                              <1>             vpxor xmm0,xmm0,xmm0   
   732                              <1>          %elif immvalue == 0x02     ; one qword ff
   733                              <1>             mov rax, -1
   734                              <1>             vmovq  xmm0, rax
   735                              <1>             vshufpd xmm0,xmm0,xmm0,02h
   736                              <1>          %elif immvalue == 0x55     ; alternate 00 ff qwords
   737                              <1>             mov rax, -1
   738                              <1>             vmovq  xmm0, rax
   739                              <1>             vshufpd ymm0,ymm0,ymm0,05h
   740                              <1>             vinsertf128 ymm0,ymm0,xmm0,1
   741                              <1>          %elif immvalue == 0x33     ; alternate 00 00 ff ff qwords
   742                              <1>             vpcmpeqw xmm0,xmm0,xmm0
   743                              <1>          %elif immvalue == 0xFF     ; all bytes ff
   744                              <1>             vpcmpeqw xmm0,xmm0,xmm0
   745                              <1>             vinsertf128 ymm0,ymm0,xmm0,1
   746                              <1>          %else
   747                              <1>             %error unsupported immvalue
   748                              <1>          %endif
   749                              <1>       %endif
   750                              <1>    %endmacro
   751                              <1>    %macro testcode 0
   752                              <1>       %ifidni tmode, TRM           ; measure throughput with memory source
   753                              <1>          instruct1 reg1,reg0,[rsi]
   754                              <1>       %elifidni tmode, LRM         ; measure latency with memory source
   755                              <1>          instruct1 reg1,reg0,[rsi]
   756                              <1>          vmovaps [rsi], reg1
   757                              <1>       %elifidni tmode, TMR           ; measure throughput with memory destination
   758                              <1>          instruct1 [rsi],reg0,reg1
   759                              <1>       %elifidni tmode, LMR           ; measure latency with memory destination
   760                              <1>          instruct1 [rsi],reg0,reg1
   761                              <1>          vmovaps reg1,[rsi]
   762                              <1>       %else
   763                              <1>          %error unknown testmode
   764                              <1>       %endif
   765                              <1>    %endmacro
   766                              <1> 
   767                              <1> %elifidni instruct, ldmxcsr
   768                              <1> 
   769                              <1>    %define repeat1 100
   770                              <1>    %define repeat2 1
   771                              <1>    %macro testinit2 0
   772                              <1>       stmxcsr [rsi+16]
   773                              <1>       mov  eax, [rsi+16]
   774                              <1>       xor  eax, 8040h
   775                              <1>       mov  [rsi], eax
   776                              <1>    %endmacro
   777                              <1>    %macro testcode 0
   778                              <1>       %ifidni tmode, T           ; measure throughput
   779                              <1>          %rep 50
   780                              <1>             ldmxcsr [rsi]
   781                              <1>             ldmxcsr [rsi+16]     ; alternate between different values
   782                              <1>          %endrep
   783                              <1>       %endif
   784                              <1>    %endmacro
   785                              <1> 
   786                              <1> %elifidni instruct, stmxcsr
   787                              <1> 
   788                              <1>    %define repeat1 100
   789                              <1>    %define repeat2 100
   790                              <1>    %macro testinit2 0
   791                              <1>       stmxcsr [rsi]
   792                              <1>    %endmacro
   793                              <1>    %macro testcode 0
   794                              <1>       %ifidni tmode, T           ; measure throughput
   795                              <1>          stmxcsr [rsi]
   796                              <1>       %elifidni tmode, L         ; measure latency + ldmxcsr
   797                              <1>          ldmxcsr [rsi]
   798                              <1>          stmxcsr [rsi]
   799                              <1>       %endif
   800                              <1>    %endmacro
   801                              <1> 
   802                              <1> %elifidni instruct, add
   803                              <1> 
   804                              <1>    %define repeat1 100
   805                              <1>    %macro testcode 0
   806                              <1>       prefix instruct [rsi],reg0
   807                              <1>    %endmacro
   808                              <1> 
   809                              <1> %elifidni instruct, xadd
   810                              <1> 
   811                              <1>    %define repeat1 100
   812                              <1>    %macro testcode 0
   813                              <1>       prefix instruct [rsi],reg0
   814                              <1>    %endmacro
   815                              <1> 
   816                              <1> %elifidni instruct, cmpxchg
   817                              <1> 
   818                              <1>    %define repeat1 100
   819                              <1>    %macro testcode 0
   820                              <1>       prefix instruct [rsi],reg0
   821                              <1>    %endmacro
   822                              <1> 
   823                              <1> %elifidni instruct, cmpxchg8b
   824                              <1> 
   825                              <1>    %define repeat1 100
   826                              <1>    %macro testcode 0
   827                              <1>       prefix instruct [rsi]
   828                              <1>    %endmacro
   829                              <1> 
   830                              <1> %elifidni instruct, cmpxchg16b
   831                              <1> 
   832                              <1>    %define repeat1 100
   833                              <1>    %macro testcode 0
   834                              <1>       prefix instruct [rsi]
   835                              <1>    %endmacro
   836                              <1> 
   837                              <1> 
   838                              <1> %else
   839                              <1> 
   840                              <1>    %error unknown instruct
   841                              <1> 
   842                              <1> ;   %define repeat1 0       ; disable default loops
   843                              <1> ;   %define repeat2 1
   844                              <1> 
   845                              <1> 
   846                              <1> %endif
   847                              <1> 
     1                                  ;----------------------------------------------------------------------------
     2                                  ;                       TemplateB32.nasm                2013-08-20 Agner Fog
     3                                  ;
     4                                  ;                PMC Test program for multiple threads
     5                                  ;                           YASM syntax
     6                                  ;
     7                                  ; This file is a replacement for the file PMCTestB32.nasm where relevant 
     8                                  ; parts are coded as replaceable macros. This is useful for automated test
     9                                  ; scripts where the macro definitions are inserted on the command line or
    10                                  ; as included files.
    11                                  ;
    12                                  ; The following defines and macros can be defined on the command line or in include files:
    13                                  ; 
    14                                  ; instruct:      The name of a single instruction to test (define or macro). Default = nop
    15                                  ;
    16                                  ; instruct2:     Extra lines of code following instruction. Default = nothing
    17                                  ;
    18                                  ; regsize:       Register size: 8, 16, 32, 65, 128, 256, (65 = mmx). Default = 32
    19                                  ;
    20                                  ; numop:         Number of register operands (0 - 3). Default = 0
    21                                  ;
    22                                  ; numimm:        Number of immediate operands (0 - 1). Default = 0
    23                                  ;
    24                                  ; immvalue:      Value of first immediate operand. Default = 0
    25                                  ;
    26                                  ; testcode:      A multi-line macro executing any piece of test code. (Replaces instruction and numop); 
    27                                  ;
    28                                  ; testdata:      Macro defining any static data needed for test. Default = 10000H bytes
    29                                  ; 
    30                                  ; testinit1:     Macro with initializations before all tests. Default sets rsi to point to testdata
    31                                  ;
    32                                  ; testinit2:     Macro with initializations before each test. Default = nothing
    33                                  ;
    34                                  ; testinit3:     Macro with initializations before macro loop. Default = nothing
    35                                  ;
    36                                  ; testinitc:     Macro to call in each test before reading counters
    37                                  ;
    38                                  ; testafter1:    Macro with any cleanup to do after macro loop. Default = nothing
    39                                  ;
    40                                  ; testafter2:    Macro with any cleanup to do after repeat1 loop. Default = nothing
    41                                  ;
    42                                  ; testafter3:    Macro with any cleanup to do after all tests. Default = nothing
    43                                  ;
    44                                  ; repeat0:       Number of repetitions of whole test. Default = 5
    45                                  ;
    46                                  ; repeat1:       Repeat count for loop around testcode. Default = no loop
    47                                  ;
    48                                  ; repeat2:       Repeat count for repeat macro around testcode. Default = 100
    49                                  ;
    50                                  ; nthreads:      Number of simultaneous threads (default = 1)
    51                                  ; 
    52                                  ; counters:      A comma-separated list of PMC counter numbers (referring to CounterDefinitions in PMCTestA.cpp)
    53                                  ;                Default = include "countertypes.inc"
    54                                  ; 
    55                                  ; WINDOWS:       1 if Windows operating system. Default = 0
    56                                  ;
    57                                  ; USEAVX:        1 if AVX registers used. Default = 0
    58                                  ;
    59                                  ; WARMUPCOUNT:   Set to 10000000 to get CPU into max frequency by executing dummy instructions. Default = 10000000
    60                                  ;
    61                                  ; CACHELINESIZE: Size of data cache lines. Default = 64
    62                                  ;
    63                                  ; codealign:     Alignment of test code. Default = 16
    64                                  ;
    65                                  ; 
    66                                  ; See PMCTestB64.nasm and PMCTest.txt for general instructions.
    67                                  ; 
    68                                  ; (c) 2000-2013 GNU General Public License www.gnu.org/licenses
    69                                  ; 
    70                                  ;-----------------------------------------------------------------------------
    71                                  
    72                                  %include "countertypes.inc"   ; include file defining various parameters
     1                              <1> ; This file is autogenerated. Edit vars.sh and init.sh instead
     2                              <1> 
     3                              <1> ; Operating system:
     4                              <1> %define UNIX 1
     5                              <1> 
     6                              <1> ; CPU:
     7                              <1> %define CPUbrand Intel
     8                              <1> %define ifamily 6
     9                              <1> %define imodel 60
    10                              <1> 
    11                              <1> ; Define whether AVX and YMM registers used
    12                              <1> %define  USEAVX   1
    13                              <1> 
    14                              <1> ; PMC counters:
    15                              <1> %ifndef counters
    16                              <1> %define counters 9
    17                              <1> %endif
    18                              <1> 
    73                                  
    74                                  ; Define any undefined macros
    75                                  
    76                                  %ifndef repeat1
    77                                     %define repeat1 1
    78                                  %endif
    79                                  
    80                                  %ifndef repeat2
    81                                     %define repeat2 100
    82                                  %endif
    83                                  
    84                                  %ifndef instruct
    85                                     %define instruct  nop  ; default instruction is NOP
    86                                  %endif
    87                                  
    88                                  %ifndef instruct2
    89                                     %define instruct2
    90                                  %endif
    91                                  
    92                                  %ifndef instruct3
    93                                     %define instruct3
    94                                  %endif
    95                                  
    96                                  %ifndef instruct4
    97                                     %define instruct4
    98                                  %endif
    99                                  
   100                                  %ifndef regsize              ; default: define registers as 32 bit
   101                                     %define regsize   32
   102                                  %endif
   103                                  
   104                                  %ifndef codealign            ; default: align test code by 16
   105                                     %define codealign 16
   106                                  %endif
   107                                  
   108                                  %ifndef numop
   109                                     %define numop  0    ; default number of register operands
   110                                  %endif
   111                                  
   112                                  %ifndef immvalue
   113                                     %define immvalue  0  ; value of immediate operands
   114                                  %endif
   115                                  
   116                                  %ifndef numimm
   117                                     %define numimm  0  ; default number of immediate operands
   118                                  %endif
   119                                  
   120                                  %if numimm == 0
   121                                     %define immoperands0 
   122                                     %define immoperands1
   123                                  %elif numimm == 1
   124                                     %define immoperands0   immvalue
   125                                     %define immoperands1 , immvalue
   126                                  %elif numimm == 2
   127                                     %define immoperands0   immvalue , immvalue
   128                                     %define immoperands1 , immvalue , immvalue
   129                                  %endif
   130                                  
   131                                  %ifnmacro testcode
   132                                     %macro testcode 0   ; default: run instruction 100 times
   133                                        %if numop == 0
   134                                           instruct immoperands0
   135                                        %elif numop == 1
   136                                           instruct reg0 immoperands1
   137                                        %elif numop == 2
   138                                           instruct reg0, reg1 immoperands1
   139                                        %elif numop == 3
   140                                           instruct reg0, reg0, reg1 immoperands1
   141                                        %else
   142                                           %error "unknown numop"
   143                                        %endif
   144                                        instruct2
   145                                     %endmacro
   146                                  %endif
   147                                  
   148                                  ; Operating system: 0 = Linux, 1 = Windows
   149                                  %ifndef WINDOWS
   150                                  %define  WINDOWS  0
   151                                  %endif
   152                                  
   153                                  ; Warmup code. Set to 10000000 to get CPU into max frequency
   154                                  %ifndef 
   155                                  %define WARMUPCOUNT 100000
   156                                  %endif
   157                                  
   158                                  ; Define cache line size (to avoid threads sharing cache lines):
   159                                  %ifndef CACHELINESIZE
   160                                  %define CACHELINESIZE  64
   161                                  %endif
   162                                  
   163                                  ; Define whether AVX and YMM registers used
   164                                  %ifndef  USEAVX
   165                                  %define  USEAVX   0
   166                                  %endif
   167                                  
   168                                  ; Number of repetitions of test.
   169                                  %ifdef   repeat0
   170                                  %define  REPETITIONS  repeat0
   171                                  %else
   172                                  %define  REPETITIONS  1
   173                                  %endif
   174                                  
   175                                  %ifndef nthreads
   176                                     %define nthreads  1    ; default number of threads = 1
   177                                  %endif
   178                                  
   179                                  %ifndef counters
   180                                     % define counters 1,9,100,150
   181                                  %endif
   182                                  
   183                                  
   184                                  %if regsize == 8             ; define registers of desired size
   185                                     %define reg0  al
   186                                     %define reg1  bl
   187                                     %define reg2  cl
   188                                     %define reg3  dl
   189                                     %define sizeptr byte
   190                                  %elif regsize == 9           ; high 8-bit registers
   191                                     %define reg0  ah
   192                                     %define reg1  bh
   193                                     %define reg2  ch
   194                                     %define reg3  dh
   195                                     %define reg4  al
   196                                     %define reg5  bl
   197                                     %define sizeptr byte
   198                                  %elif regsize == 16
   199                                     %define reg0  ax
   200                                     %define reg1  bx
   201                                     %define reg2  cx
   202                                     %define reg3  dx
   203                                     %define reg4  di
   204                                     %define reg5  si
   205                                     %define reg6  bp
   206                                     %define sizeptr word
   207                                  %elif regsize == 32
   208                                     %define reg0  eax
   209                                     %define reg1  ebx
   210                                     %define reg2  ecx
   211                                     %define reg3  edx
   212                                     %define reg4  edi
   213                                     %define reg5  esi
   214                                     %define reg6  ebp
   215                                     %define sizeptr dword
   216                                  %elif regsize == 65    ; 64 bit mmx registers
   217                                     %define reg0  mm0
   218                                     %define reg1  mm1
   219                                     %define reg2  mm2
   220                                     %define reg3  mm3
   221                                     %define reg4  mm4
   222                                     %define reg5  mm5
   223                                     %define reg6  mm6
   224                                     %define reg7  mm7
   225                                     %define sizeptr mmword   
   226                                  %elif regsize == 128
   227                                     %define reg0  xmm0
   228                                     %define reg1  xmm1
   229                                     %define reg2  xmm2
   230                                     %define reg3  xmm3
   231                                     %define reg4  xmm4
   232                                     %define reg5  xmm5
   233                                     %define reg6  xmm6
   234                                     %define reg7  xmm7
   235                                     %define sizeptr xmmword   
   236                                  %elif regsize == 256
   237                                     %define reg0  ymm0
   238                                     %define reg1  ymm1
   239                                     %define reg2  ymm2
   240                                     %define reg3  ymm3
   241                                     %define reg4  ymm4
   242                                     %define reg5  ymm5
   243                                     %define reg6  ymm6
   244                                     %define reg7  ymm7
   245                                     %define sizeptr ymmword   
   246                                  %elif regsize == 0        ; unspecified size
   247                                     %define sizeptr 
   248                                  %else
   249                                     %error unknown register size
   250                                  %endif
   251                                  
   252                                  %define modesize 32  ; indicate 32 bit mode
   253                                  
   254                                  ;-----------------------------------------------------------------------------
   255                                  
   256                                  global TestLoop
   257                                  global NumCounters
   258                                  global MaxNumCounters
   259                                  global EventRegistersUsed
   260                                  global UsePMC
   261                                  global Counters
   262                                  global CounterTypesDesired
   263                                  global PThreadData
   264                                  global ClockResultsOS
   265                                  global PMCResultsOS
   266                                  global NumThreads
   267                                  global ThreadDataSize
   268                                  global RatioOut
   269                                  global TempOut
   270                                  global RatioOutTitle
   271                                  global TempOutTitle
   272                                  
   273                                  
   274                                  SECTION .data   align = CACHELINESIZE
   275                                  
   276                                  ;##############################################################################
   277                                  ;#
   278                                  ;#            List of desired counter types and other user definitions
   279                                  ;#
   280                                  ;##############################################################################
   281                                   
   282                                  ; Here you can select which performance monitor counters you want for your test.
   283                                  ; Select id numbers from the table CounterDefinitions[] in PMCTestA.cpp.
   284                                  
   285                                  %define USE_PERFORMANCE_COUNTERS   1        ; Tell if you are using performance counters
   286                                  
   287                                  ; Maximum number of PMC counters
   288                                  %define MAXCOUNTERS   6              ; must match value in PMCTest.h
   289                                  
   290                                  ; Number of PMC counters
   291                                  %define NUM_COUNTERS  1
   292                                  
   293                                  CounterTypesDesired:
   294 00000000 09000000                    DD      counters                 ; macro with desired counter numbers
   295 00000004 00000000<rept>          times (MAXCOUNTERS - ($-CounterTypesDesired)/4)  DD 0
   296                                  
   297                                  ; Number of threads
   298                                  %define NUM_THREADS   nthreads
   299                                  
   300                                  ; Subtract overhead from clock counts (0 if not)
   301                                  %define SUBTRACT_OVERHEAD  0
   302                                  
   303                                  ; Number of repetitions in loop to find overhead
   304                                  %define OVERHEAD_REPETITIONS  1
   305                                  
   306                                  ; Define array sizes
   307                                  %assign MAXREPEAT  REPETITIONS
   308                                  
   309                                  ;##############################################################################
   310                                  ;#
   311                                  ;#                       global data
   312                                  ;#
   313                                  ;##############################################################################
   314                                  
   315                                  ; Per-thread data:
   316 00000018 00<rept>                align   CACHELINESIZE, DB 0
   317                                  ; Data for first thread
   318                                  ThreadData:                                                ; beginning of thread data block
   319 00000040 00000000<rept>          CountTemp:     times  (MAXCOUNTERS + 1)          DD   0    ; temporary storage of counts
   320 0000005C FFFFFFFF<rept>          CountOverhead: times  (MAXCOUNTERS + 1)          DD  -1    ; temporary storage of count overhead
   321 00000078 00000000                ClockResults:  times   REPETITIONS               DD   0    ; clock counts
   322 0000007C 00000000<rept>          PMCResults:    times  (REPETITIONS*MAXCOUNTERS)  DD   0    ; PMC counts
   323 00000094 00<rept>                ALIGN   CACHELINESIZE, DB 0                                ; Make sure threads don't use same cache lines
   324                                  THREADDSIZE  equ     ($ - ThreadData)                      ; size of data block for each thread
   325                                  
   326                                  ; Define data blocks of same size for remaining threads
   327                                  %if  NUM_THREADS > 1
   328                                    times ((NUM_THREADS-1)*THREADDSIZE)            DB 0
   329                                  %endif
   330                                  
   331                                  ; Global data
   332 000000C0 [40000000]              PThreadData     DD    ThreadData                ; Pointer to measured data for all threads
   333 000000C4 00000000                NumCounters     DD    0                         ; Will be number of valid counters
   334 000000C8 01000000                MaxNumCounters  DD    NUM_COUNTERS              ; Tell PMCTestA.CPP length of CounterTypesDesired
   335 000000CC 01000000                UsePMC          DD    USE_PERFORMANCE_COUNTERS  ; Tell PMCTestA.CPP if RDPMC used. Driver needed
   336 000000D0 01000000                NumThreads      DD    NUM_THREADS               ; Number of threads
   337 000000D4 80000000                ThreadDataSize  DD    THREADDSIZE               ; Size of each thread data block
   338 000000D8 38000000                ClockResultsOS  DD    ClockResults-ThreadData   ; Offset to ClockResults
   339 000000DC 3C000000                PMCResultsOS    DD    PMCResults-ThreadData     ; Offset to PMCResults
   340 000000E0 00000000<rept>          Counters              times MAXCOUNTERS   DD 0  ; Counter register numbers used will be inserted here
   341 000000F8 00000000<rept>          EventRegistersUsed    times MAXCOUNTERS   DD 0  ; Set by MTMonA.cpp
   342                                  
   343                                  
   344                                  %if NUM_THREADS == 1
   345 00000110 00000000                ESP_SAVE         dd    0                         ; Save stack pointer if only one thread
   346                                  %endif
   347                                  
   348                                  
   349                                  %ifmacro extraoutput                            ; define optional extra output columns
   350                                     extraoutput
   351                                  %else
   352 00000114 000000000000000000-        RatioOut      DD   0, 0, 0, 0                ; optional ratio output. Se PMCTest.h
   352 0000011D 00000000000000     
   353 00000124 00000000                   TempOut       DD   0                         ; optional arbitrary output. Se PMCTest.h
   354 00000128 00000000                   RatioOutTitle DD   0                         ; optional column heading
   355 0000012C 00000000                   TempOutTitle  DD   0                         ; optional column heading
   356                                  %endif  
   357                                  
   358                                  
   359                                  ;##############################################################################
   360                                  ;#
   361                                  ;#                 User data
   362                                  ;#
   363                                  ;##############################################################################
   364 00000130 00<rept>                ALIGN   CACHELINESIZE, DB 0
   365                                  
   366                                  ; Put any data definitions your test code needs here
   367                                  
   368                                  UserData:
   369                                  %ifmacro testdata
   370                                          testdata
   371                                  %else
   372 00000140 00<rept>                        times 10000H  DB 0
   373                                  %endif
   374                                  
   375                                  ;##############################################################################
   376                                  ;#
   377                                  ;#                 Macro definitions used in test loop
   378                                  ;#
   379                                  ;##############################################################################
   380                                  
   381                                  %macro SERIALIZE 0             ; serialize CPU
   382                                         xor     eax, eax
   383                                         cpuid
   384                                  %endmacro
   385                                  
   386                                  %macro CLEARXMMREG 1           ; clear one xmm register
   387                                     pxor xmm%1, xmm%1
   388                                  %endmacro 
   389                                  
   390                                  %macro CLEARALLXMMREG 0        ; set all xmm or ymm registers to 0
   391                                     %if  USEAVX
   392                                       ; VZEROALL                 ; set all ymm registers to 0
   393                                     %else
   394                                        %assign i 0
   395                                        %rep 8
   396                                           CLEARXMMREG i         ; set all 8 xmm registers to 0
   397                                           %assign i i+1
   398                                        %endrep
   399                                     %endif
   400                                  %endmacro
   401                                  
   402                                  
   403                                  ;##############################################################################
   404                                  ;#
   405                                  ;#                    Test Loop
   406                                  ;#
   407                                  ;##############################################################################
   408                                  
   409                                  SECTION .text   align = codealign
   410                                  
   411                                  ;extern "C" ;extern "C" int TestLoop (int thread) {
   412                                  ; This function runs the code to test REPETITIONS times
   413                                  ; and reads the counters before and after each run:
   414                                  
   415                                  TestLoop:
   416 00000000 53                              push    ebx
   417 00000001 56                              push    esi
   418 00000002 57                              push    edi
   419 00000003 55                              push    ebp
   420 00000004 8B442414                        mov     eax, [esp+16+4]            ; Thread number
   421                                          
   422                                  ; local variables:
   423                                  ;   [esp]:   thread number
   424                                  ;   [esp+4]: pointer to thread data block
   425                                  ;   [esp+8]: loop counter
   426                                  
   427 00000008 6A00                            push    0
   428 0000000A 6A00                            push    0
   429 0000000C 50                              push    eax
   430                                          
   431                                  %if NUM_THREADS == 1
   432                                        ; mov     [ESP_SAVE], esp            ; Save stack pointer if only one thread
   433                                  %endif
   434                                  
   435                                          
   436                                  ;##############################################################################
   437                                  ;#
   438                                  ;#                 Warm up
   439                                  ;#
   440                                  ;##############################################################################
   441                                  ; Get into max frequency state
   442                                  
   443                                  %if WARMUPCOUNT
   444                                  
   445 0000000D B910270000                      mov ecx, WARMUPCOUNT / 10
   446 00000012 B801000000                      mov eax, 1
   447 00000017 90<rept>                        align 16
   448                                  Warmuploop:
   449                                          %rep 10
   450                                          imul eax, ecx
   451                                          %endrep
   451 00000020 0FAFC1              <1>  imul eax, ecx
   451 00000023 0FAFC1              <1>  imul eax, ecx
   451 00000026 0FAFC1              <1>  imul eax, ecx
   451 00000029 0FAFC1              <1>  imul eax, ecx
   451 0000002C 0FAFC1              <1>  imul eax, ecx
   451 0000002F 0FAFC1              <1>  imul eax, ecx
   451 00000032 0FAFC1              <1>  imul eax, ecx
   451 00000035 0FAFC1              <1>  imul eax, ecx
   451 00000038 0FAFC1              <1>  imul eax, ecx
   451 0000003B 0FAFC1              <1>  imul eax, ecx
   452 0000003E 49                              dec ecx
   453 0000003F 75DF                            jnz Warmuploop
   454                                  
   455                                  %endif
   456                                  
   457                                  
   458                                  ;##############################################################################
   459                                  ;#
   460                                  ;#                 User Initializations 
   461                                  ;#
   462                                  ;##############################################################################
   463                                  ; You may add any initializations your test code needs here.
   464                                  ; Registers esi, edi, ebp and r8 - r12 will be unchanged from here to the 
   465                                  ; Test code start.
   466                                  
   467 00000041 9BDBE3                          finit                ; clear all FP registers
   468                                          
   469                                          CLEARALLXMMREG       ; clear all xmm or ymm registers
   469                              <1>  %if USEAVX
   469                              <1> 
   469                              <1>  %else
   469                              <1>  %assign i 0
   469                              <1>  %rep 8
   469                              <1>  CLEARXMMREG i
   469                              <1>  %assign i i+1
   469                              <1>  %endrep
   469                              <1>  %endif
   470                                  
   471 00000044 69042420200000                  imul eax, [esp], 2020h ; separate data for each thread
   472 0000004B 8DB0[40010000]                  lea esi, [eax+UserData]
   473 00000051 8DBE20010000                    lea edi, [esi+120h]
   474 00000057 31ED                            xor ebp, ebp
   475                                          
   476                                  %define psi esi              ; esi in 32-bit mode, rsi in 64-bit mode
   477                                        
   478                                  %ifmacro testinit1
   479                                          testinit1
   480                                  %endif
   481                                  
   482                                  
   483                                  ;##############################################################################
   484                                  ;#
   485                                  ;#                 End of user Initializations 
   486                                  ;#
   487                                  ;##############################################################################
   488                                  
   489 00000059 BB[40000000]                    mov     ebx, ThreadData               ; address of first thread data block
   490 0000005E 69042480000000                  imul    eax, [esp], THREADDSIZE       ; offset to thread data block
   491 00000065 01C3                            add     ebx, eax                      ; address of current thread data block
   492 00000067 895C2404                        mov     [esp+4], ebx                  ; save on stack
   493                                  
   494                                  %if  SUBTRACT_OVERHEAD
   495                                  First test loop. Measure empty code
   496                                          mov     dword [esp+8], 0              ; Loop counter
   497                                  
   498                                  TEST_LOOP_1:
   499                                  
   500                                          SERIALIZE
   501                                  
   502                                          mov     ebx, [esp+4]      
   503                                          ; Read counters
   504                                  %assign i  0
   505                                  %rep    NUM_COUNTERS
   506                                          mov     ecx, [Counters + i*4]
   507                                          rdpmc
   508                                          mov     [ebx + i*4 + 4 + (CountTemp-ThreadData)], eax
   509                                  %assign i  i+1
   510                                  %endrep
   511                                  
   512                                          SERIALIZE
   513                                  
   514                                   ;       mov     ebx, [esp+4]      
   515                                          ; read time stamp counter
   516                                    ;      rdtsc
   517                                    ;      mov     [ebx + (CountTemp-ThreadData)], eax
   518                                  
   519                                     ;     SERIALIZE
   520                                  
   521                                          ; Empty. Test code goes here in next loop
   522                                  
   523                                      ;    SERIALIZE
   524                                  
   525                                       ;   mov     ebx, [esp+4]      
   526                                          ; read time stamp counter
   527                                        ;  rdtsc
   528                                         ; sub     [ebx + (CountTemp-ThreadData)], eax        ; CountTemp[0]
   529                                  
   530                                          ;SERIALIZE
   531                                  
   532                                          mov     ebx, [esp+4]      
   533                                          ; Read counters
   534                                  %assign i  0
   535                                  %rep    NUM_COUNTERS
   536                                          mov     ecx, [Counters + i*4]
   537                                          rdpmc
   538                                          sub     [ebx + i*4 + 4 + (CountTemp-ThreadData)], eax  ; CountTemp[i+1]
   539                                  %assign i  i+1
   540                                  %endrep
   541                                  
   542                                         SERIALIZE
   543                                  
   544                                    ;      mov     ebx, [esp+4]      
   545                                          ; find minimum counts
   546                                  ;%assign i  0
   547                                  ;%rep    NUM_COUNTERS + 1
   548                                  ;        mov     eax, [ebx+i*4+(CountTemp-ThreadData)]      ; -count
   549                                  ;        neg     eax
   550                                  ;        mov     edx, [ebx+i*4+(CountOverhead-ThreadData)]  ; previous count
   551                                  ;        cmp     eax, edx
   552                                   ;       cmovb   edx, eax
   553                                   ;       mov     [ebx+i*4+(CountOverhead-ThreadData)], edx  ; minimum count        
   554                                  ;%assign i  i+1
   555                                  ;%endrep
   556                                          
   557                                  ;        ; end second test loop
   558                                  ;        inc     dword [esp+8]
   559                                  ;        cmp     dword [esp+8], OVERHEAD_REPETITIONS
   560                                  ;        jb      TEST_LOOP_1
   561                                  
   562                                  %endif   ; SUBTRACT_OVERHEAD
   563                                  
   564                                          
   565                                  ; Second test loop. Measure user code
   566 0000006B C744240800000000                mov     dword [esp+8], 0          ; Loop counter
   567                                  
   568                                  TEST_LOOP_2:
   569                                  
   570                                  %ifmacro testinitc
   571                                          testinitc
   572                                  %endif
   573                                  
   574                                          SERIALIZE
   574 00000073 31C0                <1>  xor eax, eax
   574 00000075 0FA2                <1>  cpuid
   575                                        
   576 00000077 8B5C2404                        mov     ebx, [esp+4]
   577                                          
   578                                          ; Read counters
   579                                  %assign i  0
   580                                  %rep    NUM_COUNTERS
   581                                          mov     ecx, [Counters + i*4]
   582                                          rdpmc
   583                                          mov     [ebx + i*4 + 4 + (CountTemp-ThreadData)], eax
   584                                  %assign i  i+1
   585                                  %endrep
   585 0000007B 8B0D[E0000000]      <1>  mov ecx, [Counters + i*4]
   585 00000081 0F33                <1>  rdpmc
   585 00000083 894304              <1>  mov [ebx + i*4 + 4 + (CountTemp-ThreadData)], eax
   585                              <1> %assign i i+1
   586                                  
   587                                          SERIALIZE
   587 00000086 31C0                <1>  xor eax, eax
   587 00000088 0FA2                <1>  cpuid
   588                                  
   589                                  ;        mov     ebx, [esp+4]      
   590                                          ; read time stamp counter
   591                                  ;        rdtsc
   592                                  ;        mov     [ebx + (CountTemp-ThreadData)], eax
   593                                  
   594                                   ;       SERIALIZE
   595                                  
   596                                  ;##############################################################################
   597                                  ;#
   598                                  ;#                 Test code start
   599                                  ;#
   600                                  ;##############################################################################
   601                                  
   602                                  ; Put the assembly code to test here
   603                                  
   604                                  %ifmacro testinit2
   605                                          testinit2
   605 0000008A 89E3                <1>  mov ebx,esp
   606                                  %endif
   607                                  
   608                                  %if repeat1 > 1
   609 0000008C BD10270000                      mov ebp, repeat1
   610 00000091 90<rept>                        align codealign
   611                                  repeat1loop:
   612                                  %endif
   613                                  
   614                                  %ifmacro testinit3
   615                                          testinit3
   616                                  %endif
   617                                  
   618                                  %rep repeat2
   619                                          ; test code inserted as macro
   620                                          testcode
   621                                  %endrep
   621                              <1> 
   621                              <1>  testcode
   621 000000A0 E803000000          <2>  call $ + 8
   621 000000A5 90                  <2>  nop
   621 000000A6 90                  <2>  nop
   621 000000A7 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 000000A8 E803000000          <2>  call $ + 8
   621 000000AD 90                  <2>  nop
   621 000000AE 90                  <2>  nop
   621 000000AF 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 000000B0 E803000000          <2>  call $ + 8
   621 000000B5 90                  <2>  nop
   621 000000B6 90                  <2>  nop
   621 000000B7 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 000000B8 E803000000          <2>  call $ + 8
   621 000000BD 90                  <2>  nop
   621 000000BE 90                  <2>  nop
   621 000000BF 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 000000C0 E803000000          <2>  call $ + 8
   621 000000C5 90                  <2>  nop
   621 000000C6 90                  <2>  nop
   621 000000C7 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 000000C8 E803000000          <2>  call $ + 8
   621 000000CD 90                  <2>  nop
   621 000000CE 90                  <2>  nop
   621 000000CF 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 000000D0 E803000000          <2>  call $ + 8
   621 000000D5 90                  <2>  nop
   621 000000D6 90                  <2>  nop
   621 000000D7 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 000000D8 E803000000          <2>  call $ + 8
   621 000000DD 90                  <2>  nop
   621 000000DE 90                  <2>  nop
   621 000000DF 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 000000E0 E803000000          <2>  call $ + 8
   621 000000E5 90                  <2>  nop
   621 000000E6 90                  <2>  nop
   621 000000E7 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 000000E8 E803000000          <2>  call $ + 8
   621 000000ED 90                  <2>  nop
   621 000000EE 90                  <2>  nop
   621 000000EF 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 000000F0 E803000000          <2>  call $ + 8
   621 000000F5 90                  <2>  nop
   621 000000F6 90                  <2>  nop
   621 000000F7 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 000000F8 E803000000          <2>  call $ + 8
   621 000000FD 90                  <2>  nop
   621 000000FE 90                  <2>  nop
   621 000000FF 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000100 E803000000          <2>  call $ + 8
   621 00000105 90                  <2>  nop
   621 00000106 90                  <2>  nop
   621 00000107 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000108 E803000000          <2>  call $ + 8
   621 0000010D 90                  <2>  nop
   621 0000010E 90                  <2>  nop
   621 0000010F 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000110 E803000000          <2>  call $ + 8
   621 00000115 90                  <2>  nop
   621 00000116 90                  <2>  nop
   621 00000117 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000118 E803000000          <2>  call $ + 8
   621 0000011D 90                  <2>  nop
   621 0000011E 90                  <2>  nop
   621 0000011F 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000120 E803000000          <2>  call $ + 8
   621 00000125 90                  <2>  nop
   621 00000126 90                  <2>  nop
   621 00000127 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000128 E803000000          <2>  call $ + 8
   621 0000012D 90                  <2>  nop
   621 0000012E 90                  <2>  nop
   621 0000012F 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000130 E803000000          <2>  call $ + 8
   621 00000135 90                  <2>  nop
   621 00000136 90                  <2>  nop
   621 00000137 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000138 E803000000          <2>  call $ + 8
   621 0000013D 90                  <2>  nop
   621 0000013E 90                  <2>  nop
   621 0000013F 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000140 E803000000          <2>  call $ + 8
   621 00000145 90                  <2>  nop
   621 00000146 90                  <2>  nop
   621 00000147 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000148 E803000000          <2>  call $ + 8
   621 0000014D 90                  <2>  nop
   621 0000014E 90                  <2>  nop
   621 0000014F 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000150 E803000000          <2>  call $ + 8
   621 00000155 90                  <2>  nop
   621 00000156 90                  <2>  nop
   621 00000157 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000158 E803000000          <2>  call $ + 8
   621 0000015D 90                  <2>  nop
   621 0000015E 90                  <2>  nop
   621 0000015F 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000160 E803000000          <2>  call $ + 8
   621 00000165 90                  <2>  nop
   621 00000166 90                  <2>  nop
   621 00000167 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000168 E803000000          <2>  call $ + 8
   621 0000016D 90                  <2>  nop
   621 0000016E 90                  <2>  nop
   621 0000016F 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000170 E803000000          <2>  call $ + 8
   621 00000175 90                  <2>  nop
   621 00000176 90                  <2>  nop
   621 00000177 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000178 E803000000          <2>  call $ + 8
   621 0000017D 90                  <2>  nop
   621 0000017E 90                  <2>  nop
   621 0000017F 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000180 E803000000          <2>  call $ + 8
   621 00000185 90                  <2>  nop
   621 00000186 90                  <2>  nop
   621 00000187 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000188 E803000000          <2>  call $ + 8
   621 0000018D 90                  <2>  nop
   621 0000018E 90                  <2>  nop
   621 0000018F 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000190 E803000000          <2>  call $ + 8
   621 00000195 90                  <2>  nop
   621 00000196 90                  <2>  nop
   621 00000197 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000198 E803000000          <2>  call $ + 8
   621 0000019D 90                  <2>  nop
   621 0000019E 90                  <2>  nop
   621 0000019F 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 000001A0 E803000000          <2>  call $ + 8
   621 000001A5 90                  <2>  nop
   621 000001A6 90                  <2>  nop
   621 000001A7 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 000001A8 E803000000          <2>  call $ + 8
   621 000001AD 90                  <2>  nop
   621 000001AE 90                  <2>  nop
   621 000001AF 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 000001B0 E803000000          <2>  call $ + 8
   621 000001B5 90                  <2>  nop
   621 000001B6 90                  <2>  nop
   621 000001B7 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 000001B8 E803000000          <2>  call $ + 8
   621 000001BD 90                  <2>  nop
   621 000001BE 90                  <2>  nop
   621 000001BF 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 000001C0 E803000000          <2>  call $ + 8
   621 000001C5 90                  <2>  nop
   621 000001C6 90                  <2>  nop
   621 000001C7 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 000001C8 E803000000          <2>  call $ + 8
   621 000001CD 90                  <2>  nop
   621 000001CE 90                  <2>  nop
   621 000001CF 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 000001D0 E803000000          <2>  call $ + 8
   621 000001D5 90                  <2>  nop
   621 000001D6 90                  <2>  nop
   621 000001D7 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 000001D8 E803000000          <2>  call $ + 8
   621 000001DD 90                  <2>  nop
   621 000001DE 90                  <2>  nop
   621 000001DF 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 000001E0 E803000000          <2>  call $ + 8
   621 000001E5 90                  <2>  nop
   621 000001E6 90                  <2>  nop
   621 000001E7 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 000001E8 E803000000          <2>  call $ + 8
   621 000001ED 90                  <2>  nop
   621 000001EE 90                  <2>  nop
   621 000001EF 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 000001F0 E803000000          <2>  call $ + 8
   621 000001F5 90                  <2>  nop
   621 000001F6 90                  <2>  nop
   621 000001F7 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 000001F8 E803000000          <2>  call $ + 8
   621 000001FD 90                  <2>  nop
   621 000001FE 90                  <2>  nop
   621 000001FF 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000200 E803000000          <2>  call $ + 8
   621 00000205 90                  <2>  nop
   621 00000206 90                  <2>  nop
   621 00000207 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000208 E803000000          <2>  call $ + 8
   621 0000020D 90                  <2>  nop
   621 0000020E 90                  <2>  nop
   621 0000020F 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000210 E803000000          <2>  call $ + 8
   621 00000215 90                  <2>  nop
   621 00000216 90                  <2>  nop
   621 00000217 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000218 E803000000          <2>  call $ + 8
   621 0000021D 90                  <2>  nop
   621 0000021E 90                  <2>  nop
   621 0000021F 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000220 E803000000          <2>  call $ + 8
   621 00000225 90                  <2>  nop
   621 00000226 90                  <2>  nop
   621 00000227 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000228 E803000000          <2>  call $ + 8
   621 0000022D 90                  <2>  nop
   621 0000022E 90                  <2>  nop
   621 0000022F 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000230 E803000000          <2>  call $ + 8
   621 00000235 90                  <2>  nop
   621 00000236 90                  <2>  nop
   621 00000237 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000238 E803000000          <2>  call $ + 8
   621 0000023D 90                  <2>  nop
   621 0000023E 90                  <2>  nop
   621 0000023F 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000240 E803000000          <2>  call $ + 8
   621 00000245 90                  <2>  nop
   621 00000246 90                  <2>  nop
   621 00000247 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000248 E803000000          <2>  call $ + 8
   621 0000024D 90                  <2>  nop
   621 0000024E 90                  <2>  nop
   621 0000024F 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000250 E803000000          <2>  call $ + 8
   621 00000255 90                  <2>  nop
   621 00000256 90                  <2>  nop
   621 00000257 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000258 E803000000          <2>  call $ + 8
   621 0000025D 90                  <2>  nop
   621 0000025E 90                  <2>  nop
   621 0000025F 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000260 E803000000          <2>  call $ + 8
   621 00000265 90                  <2>  nop
   621 00000266 90                  <2>  nop
   621 00000267 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000268 E803000000          <2>  call $ + 8
   621 0000026D 90                  <2>  nop
   621 0000026E 90                  <2>  nop
   621 0000026F 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000270 E803000000          <2>  call $ + 8
   621 00000275 90                  <2>  nop
   621 00000276 90                  <2>  nop
   621 00000277 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000278 E803000000          <2>  call $ + 8
   621 0000027D 90                  <2>  nop
   621 0000027E 90                  <2>  nop
   621 0000027F 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000280 E803000000          <2>  call $ + 8
   621 00000285 90                  <2>  nop
   621 00000286 90                  <2>  nop
   621 00000287 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000288 E803000000          <2>  call $ + 8
   621 0000028D 90                  <2>  nop
   621 0000028E 90                  <2>  nop
   621 0000028F 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000290 E803000000          <2>  call $ + 8
   621 00000295 90                  <2>  nop
   621 00000296 90                  <2>  nop
   621 00000297 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000298 E803000000          <2>  call $ + 8
   621 0000029D 90                  <2>  nop
   621 0000029E 90                  <2>  nop
   621 0000029F 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 000002A0 E803000000          <2>  call $ + 8
   621 000002A5 90                  <2>  nop
   621 000002A6 90                  <2>  nop
   621 000002A7 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 000002A8 E803000000          <2>  call $ + 8
   621 000002AD 90                  <2>  nop
   621 000002AE 90                  <2>  nop
   621 000002AF 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 000002B0 E803000000          <2>  call $ + 8
   621 000002B5 90                  <2>  nop
   621 000002B6 90                  <2>  nop
   621 000002B7 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 000002B8 E803000000          <2>  call $ + 8
   621 000002BD 90                  <2>  nop
   621 000002BE 90                  <2>  nop
   621 000002BF 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 000002C0 E803000000          <2>  call $ + 8
   621 000002C5 90                  <2>  nop
   621 000002C6 90                  <2>  nop
   621 000002C7 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 000002C8 E803000000          <2>  call $ + 8
   621 000002CD 90                  <2>  nop
   621 000002CE 90                  <2>  nop
   621 000002CF 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 000002D0 E803000000          <2>  call $ + 8
   621 000002D5 90                  <2>  nop
   621 000002D6 90                  <2>  nop
   621 000002D7 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 000002D8 E803000000          <2>  call $ + 8
   621 000002DD 90                  <2>  nop
   621 000002DE 90                  <2>  nop
   621 000002DF 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 000002E0 E803000000          <2>  call $ + 8
   621 000002E5 90                  <2>  nop
   621 000002E6 90                  <2>  nop
   621 000002E7 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 000002E8 E803000000          <2>  call $ + 8
   621 000002ED 90                  <2>  nop
   621 000002EE 90                  <2>  nop
   621 000002EF 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 000002F0 E803000000          <2>  call $ + 8
   621 000002F5 90                  <2>  nop
   621 000002F6 90                  <2>  nop
   621 000002F7 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 000002F8 E803000000          <2>  call $ + 8
   621 000002FD 90                  <2>  nop
   621 000002FE 90                  <2>  nop
   621 000002FF 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000300 E803000000          <2>  call $ + 8
   621 00000305 90                  <2>  nop
   621 00000306 90                  <2>  nop
   621 00000307 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000308 E803000000          <2>  call $ + 8
   621 0000030D 90                  <2>  nop
   621 0000030E 90                  <2>  nop
   621 0000030F 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000310 E803000000          <2>  call $ + 8
   621 00000315 90                  <2>  nop
   621 00000316 90                  <2>  nop
   621 00000317 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000318 E803000000          <2>  call $ + 8
   621 0000031D 90                  <2>  nop
   621 0000031E 90                  <2>  nop
   621 0000031F 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000320 E803000000          <2>  call $ + 8
   621 00000325 90                  <2>  nop
   621 00000326 90                  <2>  nop
   621 00000327 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000328 E803000000          <2>  call $ + 8
   621 0000032D 90                  <2>  nop
   621 0000032E 90                  <2>  nop
   621 0000032F 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000330 E803000000          <2>  call $ + 8
   621 00000335 90                  <2>  nop
   621 00000336 90                  <2>  nop
   621 00000337 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000338 E803000000          <2>  call $ + 8
   621 0000033D 90                  <2>  nop
   621 0000033E 90                  <2>  nop
   621 0000033F 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000340 E803000000          <2>  call $ + 8
   621 00000345 90                  <2>  nop
   621 00000346 90                  <2>  nop
   621 00000347 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000348 E803000000          <2>  call $ + 8
   621 0000034D 90                  <2>  nop
   621 0000034E 90                  <2>  nop
   621 0000034F 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000350 E803000000          <2>  call $ + 8
   621 00000355 90                  <2>  nop
   621 00000356 90                  <2>  nop
   621 00000357 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000358 E803000000          <2>  call $ + 8
   621 0000035D 90                  <2>  nop
   621 0000035E 90                  <2>  nop
   621 0000035F 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000360 E803000000          <2>  call $ + 8
   621 00000365 90                  <2>  nop
   621 00000366 90                  <2>  nop
   621 00000367 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000368 E803000000          <2>  call $ + 8
   621 0000036D 90                  <2>  nop
   621 0000036E 90                  <2>  nop
   621 0000036F 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000370 E803000000          <2>  call $ + 8
   621 00000375 90                  <2>  nop
   621 00000376 90                  <2>  nop
   621 00000377 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000378 E803000000          <2>  call $ + 8
   621 0000037D 90                  <2>  nop
   621 0000037E 90                  <2>  nop
   621 0000037F 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000380 E803000000          <2>  call $ + 8
   621 00000385 90                  <2>  nop
   621 00000386 90                  <2>  nop
   621 00000387 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000388 E803000000          <2>  call $ + 8
   621 0000038D 90                  <2>  nop
   621 0000038E 90                  <2>  nop
   621 0000038F 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000390 E803000000          <2>  call $ + 8
   621 00000395 90                  <2>  nop
   621 00000396 90                  <2>  nop
   621 00000397 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 00000398 E803000000          <2>  call $ + 8
   621 0000039D 90                  <2>  nop
   621 0000039E 90                  <2>  nop
   621 0000039F 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 000003A0 E803000000          <2>  call $ + 8
   621 000003A5 90                  <2>  nop
   621 000003A6 90                  <2>  nop
   621 000003A7 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 000003A8 E803000000          <2>  call $ + 8
   621 000003AD 90                  <2>  nop
   621 000003AE 90                  <2>  nop
   621 000003AF 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 000003B0 E803000000          <2>  call $ + 8
   621 000003B5 90                  <2>  nop
   621 000003B6 90                  <2>  nop
   621 000003B7 90                  <2>  nop
   621                              <1> 
   621                              <1>  testcode
   621 000003B8 E803000000          <2>  call $ + 8
   621 000003BD 90                  <2>  nop
   621 000003BE 90                  <2>  nop
   621 000003BF 90                  <2>  nop
   622                                  
   623                                  %ifmacro testafter1
   624                                          testafter1
   624 000003C0 89DC                <1>  mov esp,ebx
   625                                  %endif
   626                                  
   627                                  %if repeat1 > 1
   628 000003C2 4D                              dec ebp
   629 000003C3 0F85D7FCFFFF                    jnz repeat1loop
   630                                  %endif
   631                                  
   632                                  %ifmacro testafter2
   633                                          testafter2
   634                                  %endif
   635                                  
   636                                  ;##############################################################################
   637                                  ;#
   638                                  ;#                 Test code end
   639                                  ;#
   640                                  ;##############################################################################
   641                                  
   642                                          SERIALIZE
   642 000003C9 31C0                <1>  xor eax, eax
   642 000003CB 0FA2                <1>  cpuid
   643                                  
   644                                  ;        mov     ebx, [esp+4]
   645                                          
   646                                          ; read time stamp counter
   647                                  ;        rdtsc
   648                                  ;        sub     [ebx + (CountTemp-ThreadData)], eax        ; CountTemp[0]
   649                                  
   650                                   ;       SERIALIZE
   651                                  
   652 000003CD 8B5C2404                        mov     ebx, [esp+4]      
   653                                          ; Read counters
   654                                  %assign i  0
   655                                  %rep    NUM_COUNTERS
   656                                          mov     ecx, [Counters + i*4]
   657                                          rdpmc
   658                                          sub     [ebx + i*4 + 4 + (CountTemp-ThreadData)], eax  ; CountTemp[i+1]
   659                                  %assign i  i+1
   660                                  %endrep        
   660 000003D1 8B0D[E0000000]      <1>  mov ecx, [Counters + i*4]
   660 000003D7 0F33                <1>  rdpmc
   660 000003D9 294304              <1>  sub [ebx + i*4 + 4 + (CountTemp-ThreadData)], eax
   660                              <1> %assign i i+1
   661                                  
   662                                      SERIALIZE
   662 000003DC 31C0                <1>  xor eax, eax
   662 000003DE 0FA2                <1>  cpuid
   663                                  
   664 000003E0 8B5C2404                        mov     ebx, [esp+4]
   665 000003E4 8B4C2408                        mov     ecx, [esp+8]
   666                                          ; subtract counts before from counts after
   667                                  ;        mov     eax, [ebx + (CountTemp-ThreadData)]            ; -count
   668                                  ;        neg     eax
   669                                  %if     SUBTRACT_OVERHEAD
   670                                  ;        sub     eax, [ebx+(CountOverhead-ThreadData)]   ; overhead clock count        
   671                                  %endif  ; SUBTRACT_OVERHEAD        
   672                                  ;        mov     [ebx+ecx*4+(ClockResults-ThreadData)], eax      ; save clock count
   673                                          
   674                                  %assign i  0
   675                                  %rep    NUM_COUNTERS
   676                                          mov     eax, [ebx + i*4 + 4 + (CountTemp-ThreadData)]
   677                                          neg     eax
   678                                  ;%if     SUBTRACT_OVERHEAD
   679                                  ;        sub     eax, [ebx+i*4+4+(CountOverhead-ThreadData)]   ; overhead pmc count        
   680                                  ;%endif  ; SUBTRACT_OVERHEAD        
   681                                          mov     [ebx+ecx*4+i*4*REPETITIONS+(PMCResults-ThreadData)], eax      ; save count        
   682                                  %assign i  i+1
   683                                  %endrep        
   683 000003E8 8B4304              <1>  mov eax, [ebx + i*4 + 4 + (CountTemp-ThreadData)]
   683 000003EB F7D8                <1>  neg eax
   683                              <1> 
   683                              <1> 
   683                              <1> 
   683 000003ED 89448B3C            <1>  mov [ebx+ecx*4+i*4*REPETITIONS+(PMCResults-ThreadData)], eax
   683                              <1> %assign i i+1
   684                                          
   685                                          ; end second test loop
   686 000003F1 FF442408                        inc     dword [esp+8]
   687 000003F5 837C240801                      cmp     dword [esp+8], REPETITIONS
   688 000003FA 0F8273FCFFFF                    jb      TEST_LOOP_2
   689                                  
   690                                  %ifmacro testafter3
   691                                          testafter3
   692                                  %endif
   693                                  
   694                                          ; clean up
   695 00000400 9BDBE3                          finit
   696 00000403 FC                              cld
   697                                  %if USEAVX
   698                                      ;    VZEROALL                       ; clear all ymm registers
   699                                  %endif
   700                                  
   701 00000404 1E                              push    ds
   702 00000405 07                              pop     es
   703                                  %if NUM_THREADS == 1
   704                                    ;      mov     esp, [ESP_SAVE]        ; Restore stack pointer if only one thread
   705                                  %endif
   706                                  
   707                                          ; return REPETITIONS;
   708 00000406 B801000000                      mov     eax, REPETITIONS
   709 0000040B 83C40C                          add     esp, 12
   710 0000040E 5D                              pop     ebp
   711 0000040F 5F                              pop     edi
   712 00000410 5E                              pop     esi
   713 00000411 5B                              pop     ebx
   714 00000412 C3                              ret
   715                                          
   716                                  ; End of TestLoop
